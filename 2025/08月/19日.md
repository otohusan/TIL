# 2025年8月19日

## React Compiler

自動的にReactを最適化してくれる、具体的にはReact.memo, useMemo, useCallbackなどが必要なくなる。さらに具体的にはドキュメントの[この部分](https://ja.react.dev/learn/react-compiler/introduction#what-kind-of-memoization-does-react-compiler-add)

### 既存のuseMemo、useCallback、React.memoについて
- 基本的に取り除けるし、手動の最適化よりもReact Compilerの最適化の方が正確らしい
- React Compilerを導入後に手動の最適化が残っていた場合は、コンパイラの自動推論による最適化と手動の最適化が一致するか判定し、一致しないとコンパイラはそのコンポーネントの最適化を見送る
- これは無限ループを防ぐために、useEffectの発火を止める目的で値をメモ化するといった誤った利用をされている場合に、勝手にメモ化を削除すると危険だかららしい

### 感想
- もっと早く存在知りたかった

### 参考
- https://ja.react.dev/learn/react-compiler/introduction#what-kind-of-memoization-does-react-compiler-add


<br>

## React.memo, useCallback, useMemo

### React.memo

関数コンポーネントを、「親が再レンダリングしても、そこから受け取る props が変化していなければ自身は再レンダリングしない」という性質にできる


### useMemo

- 引数に関数と、依存配列を持つ。
- 戻り値は、引数に受けた関数の戻り値と同じ

#### 使うタイミング例
- シンプルに処理の重い計算をするとき（1ms 以上が目安らしい）
- 値をスコープ外に持ち出す時、特にReact.memoを使った関数に渡している場合は、useMemo使わないとReact.memo使ってるのに再レンダーされてしまう


### useCallback
- 引数に関数と、依存配列を持つ。
- 関数定義をキャッシュして、それを返す

#### 使うタイミング例
- memo化してるコンポーネントに関すを渡す時
- useEffectやuseMemoの依存として関数を渡す場合

### 参考
- https://zenn.dev/chot/articles/react-when-to-use-memo
- https://ja.react.dev/reference/react/useCallback
- https://zenn.dev/frontendflat/articles/react-usecallback-usage


<br>

## console.time
以下みたいに、何らかの処理を挟むように記述したら、処理に要した時間がわかる？
```js
console.time('filter array');
const visibleTodos = filterTodos(todos, tab);
console.timeEnd('filter array');
```
